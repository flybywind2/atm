/**
 * Progress Tracker Component
 * 
 * This component displays the real-time progress of the analysis workflow,
 * showing current status, progress percentage, and step information.
 */

class ProgressTrackerComponent {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.currentStatus = null;
        
        if (!this.container) {
            throw new Error(`Container with ID '${containerId}' not found`);
        }
        
        this.render();
        this.bindEvents();
    }
    
    /**
     * Render the initial component HTML
     */
    render() {
        this.container.innerHTML = `
            <div class="progress-tracker">
                <div class="progress-header">
                    <h3>ë¶„ì„ ì§„í–‰ ìƒí™©</h3>
                    <div id="thread-info" class="thread-info hidden">
                        <span class="thread-label">Thread ID:</span>
                        <span id="thread-id" class="thread-id">-</span>
                    </div>
                </div>
                
                <div class="progress-bar-container">
                    <div class="progress-bar">
                        <div id="progress-fill" class="progress-fill"></div>
                    </div>
                    <div id="progress-text" class="progress-text">0% ì™„ë£Œ</div>
                </div>
                
                <div id="status-indicator" class="status-indicator">
                    <span class="status-icon">â¸ï¸</span>
                    <span id="status-text" class="status-text">ëŒ€ê¸° ì¤‘</span>
                </div>
                
                <div class="workflow-steps">
                    <div class="step-item" data-step="analyze">
                        <span class="step-number">1</span>
                        <span class="step-label">ë¬¸ì œ ë¶„ì„</span>
                        <span class="step-status">â¸ï¸</span>
                    </div>
                    <div class="step-item" data-step="context">
                        <span class="step-number">2</span>
                        <span class="step-label">ì»¨í…ìŠ¤íŠ¸ ìˆ˜ì§‘</span>
                        <span class="step-status">â¸ï¸</span>
                    </div>
                    <div class="step-item" data-step="requirements">
                        <span class="step-number">3</span>
                        <span class="step-label">ìš”êµ¬ì‚¬í•­ ì •ì˜</span>
                        <span class="step-status">â¸ï¸</span>
                    </div>
                    <div class="step-item" data-step="solution">
                        <span class="step-number">4</span>
                        <span class="step-label">ì†”ë£¨ì…˜ ì„¤ê³„</span>
                        <span class="step-status">â¸ï¸</span>
                    </div>
                    <div class="step-item" data-step="guide">
                        <span class="step-number">5</span>
                        <span class="step-label">ê°€ì´ë“œ ìƒì„±</span>
                        <span class="step-status">â¸ï¸</span>
                    </div>
                </div>
                
                <div id="current-message" class="current-message hidden">
                    <span class="message-icon">ğŸ’¬</span>
                    <span id="message-text" class="message-text"></span>
                </div>
                
                <div class="progress-actions">
                    <button id="refresh-btn" class="btn btn-secondary">ìƒíƒœ ìƒˆë¡œê³ ì¹¨</button>
                    <button id="cancel-btn" class="btn btn-danger">ì‘ì—… ì·¨ì†Œ</button>
                </div>
            </div>
        `;
    }
    
    /**
     * Bind event handlers
     */
    bindEvents() {
        const refreshBtn = this.container.querySelector('#refresh-btn');
        const cancelBtn = this.container.querySelector('#cancel-btn');
        
        refreshBtn.addEventListener('click', () => this.requestStatusUpdate());
        cancelBtn.addEventListener('click', () => this.cancelWorkflow());
    }
    
    /**
     * Update status from API response
     */
    updateStatus(status) {
        this.currentStatus = status;

        // DEBUG: Log status updates
        console.log(`[PROGRESS TRACKER] Received status update:`, {
            step: status.current_step,
            progress: status.progress_percentage,
            status: status.status,
            message: status.message
        });
        
        // Update thread ID
        const threadIdElement = this.container.querySelector('#thread-id');
        const threadInfoElement = this.container.querySelector('#thread-info');
        if (status.thread_id) {
            threadIdElement.textContent = status.thread_id;
            threadInfoElement.classList.remove('hidden');
        }
        
        // Update progress bar
        this.updateProgress(status.progress_percentage);
        
        // Update status indicator
        this.updateStatusIndicator(status.status, status.current_step);
        
        // Update workflow steps
        this.updateWorkflowSteps(status.current_step, status.status);
        
        // Update message
        this.updateMessage(status.message, status.requires_input);
        
        // Update timestamp
        this.updateLastUpdated();
    }
    
    /**
     * Update progress bar
     */
    updateProgress(percentage) {
        const progressFill = this.container.querySelector('#progress-fill');
        const progressText = this.container.querySelector('#progress-text');
        
        const safePercentage = Math.max(0, Math.min(100, percentage || 0));
        
        progressFill.style.width = `${safePercentage}%`;
        progressText.textContent = `${safePercentage}% ì™„ë£Œ`;
        
        // Add animation
        progressFill.style.transition = 'width 0.5s ease-in-out';
    }
    
    /**
     * Update status indicator
     */
    updateStatusIndicator(status, currentStep) {
        const statusIndicator = this.container.querySelector('#status-indicator');
        const statusText = this.container.querySelector('#status-text');
        const statusIcon = statusIndicator.querySelector('.status-icon');
        
        // Remove all status classes
        statusIndicator.classList.remove('processing', 'completed', 'error', 'paused');
        
        const statusConfig = {
            'STARTING': { class: 'processing', icon: 'ğŸš€', text: 'ë¶„ì„ ì‹œì‘ë¨' },
            'ANALYZING': { class: 'processing', icon: 'ğŸ”', text: 'ë¬¸ì œ ë¶„ì„ ì¤‘' },
            'COLLECTING_CONTEXT': { class: 'processing', icon: 'ğŸ“', text: 'ì»¨í…ìŠ¤íŠ¸ ìˆ˜ì§‘ ì¤‘' },
            'GENERATING_REQUIREMENTS': { class: 'processing', icon: 'ğŸ“‹', text: 'ìš”êµ¬ì‚¬í•­ ìƒì„± ì¤‘' },
            'DESIGNING_SOLUTION': { class: 'processing', icon: 'ğŸ¯', text: 'ì†”ë£¨ì…˜ ì„¤ê³„ ì¤‘' },
            'CREATING_GUIDE': { class: 'processing', icon: 'ğŸ“š', text: 'ê°€ì´ë“œ ìƒì„± ì¤‘' },
            'PROCESSING': { class: 'processing', icon: 'âš™ï¸', text: 'ì²˜ë¦¬ ì¤‘' },
            'FALLBACK_GENERATION': { class: 'processing', icon: 'ğŸ”§', text: 'í´ë°± ë¬¸ì„œ ìƒì„± ì¤‘' },
            'COMPLETED': { class: 'completed', icon: 'âœ…', text: 'ë¶„ì„ ì™„ë£Œ' },
            'AWAITING_INPUT': { class: 'paused', icon: 'â¸ï¸', text: 'ì‚¬ìš©ì ì…ë ¥ ëŒ€ê¸°' },
            'ERROR': { class: 'error', icon: 'âŒ', text: 'ì˜¤ë¥˜ ë°œìƒ' },
            // Fallback for lowercase versions
            'started': { class: 'processing', icon: 'ğŸš€', text: 'ë¶„ì„ ì‹œì‘ë¨' },
            'analyzing': { class: 'processing', icon: 'ğŸ”', text: 'ë¬¸ì œ ë¶„ì„ ì¤‘' },
            'collecting_context': { class: 'processing', icon: 'ğŸ“', text: 'ì»¨í…ìŠ¤íŠ¸ ìˆ˜ì§‘ ì¤‘' },
            'generating_requirements': { class: 'processing', icon: 'ğŸ“‹', text: 'ìš”êµ¬ì‚¬í•­ ìƒì„± ì¤‘' },
            'designing_solution': { class: 'processing', icon: 'ğŸ¯', text: 'ì†”ë£¨ì…˜ ì„¤ê³„ ì¤‘' },
            'creating_guide': { class: 'processing', icon: 'ğŸ“š', text: 'ê°€ì´ë“œ ìƒì„± ì¤‘' },
            'processing': { class: 'processing', icon: 'âš™ï¸', text: 'ì²˜ë¦¬ ì¤‘' },
            'fallback_generation': { class: 'processing', icon: 'ğŸ”§', text: 'í´ë°± ë¬¸ì„œ ìƒì„± ì¤‘' },
            'completed': { class: 'completed', icon: 'âœ…', text: 'ë¶„ì„ ì™„ë£Œ' },
            'paused': { class: 'paused', icon: 'â¸ï¸', text: 'ì‚¬ìš©ì ì…ë ¥ ëŒ€ê¸°' },
            'error': { class: 'error', icon: 'âŒ', text: 'ì˜¤ë¥˜ ë°œìƒ' }
        };
        
        const statusKey = ((status || '') === 'awaiting_input' || (String(status || '').toLowerCase() === 'awaiting_input')) ? 'paused' : status;
        const config = statusConfig[statusKey] || statusConfig['started'];
        
        statusIndicator.classList.add(config.class);
        statusIcon.textContent = config.icon;
        statusText.textContent = config.text;

        // ì²˜ë¦¬ ì¤‘ ìƒíƒœì¼ ë•Œ ì•„ì´ì½˜ì— ì• ë‹ˆë©”ì´ì…˜ ì¶”ê°€
        if (config.class === 'processing') {
            statusIcon.classList.add('spinning');
        } else {
            statusIcon.classList.remove('spinning');
        }
    }
    
    /**
     * Update workflow steps
     */
    updateWorkflowSteps(currentStep, status) {
        const stepItems = this.container.querySelectorAll('.step-item');
        const normalizedStatus = String(status || '').toLowerCase();
        const stepMapping = {
            'analyze_problem': 'analyze',
            'problem_analyzed': 'analyze',
            'collect_context': 'context',
            'collecting_context': 'context',
            'context_collected': 'context',
            'generate_requirements': 'requirements',
            'requirements_generated': 'requirements',
            'design_solution': 'solution',
            'solution_designed': 'solution',
            'create_guide': 'guide',
            'guide_created': 'guide'
        };
        
        stepItems.forEach(item => {
            const stepType = item.dataset.step;
            const statusElement = item.querySelector('.step-status');
            
            // Reset classes
            item.classList.remove('active', 'completed', 'error');
            
            // Determine step status
            if (stepMapping[currentStep] === stepType) {
                if (normalizedStatus === 'error') {
                    item.classList.add('error');
                    statusElement.textContent = 'âŒ';
                } else if (normalizedStatus === 'paused' || normalizedStatus === 'awaiting_input') {
                    item.classList.add('active');
                    statusElement.textContent = 'â¸ï¸';
                } else {
                    item.classList.add('active');
                    statusElement.textContent = 'âš™ï¸';
                    statusElement.classList.add('spinning');
                }
            } else {
                // Check if step is completed
                const stepOrder = ['analyze', 'context', 'requirements', 'solution', 'guide'];
                const currentIndex = stepOrder.indexOf(stepMapping[currentStep]);
                const stepIndex = stepOrder.indexOf(stepType);

                if (stepIndex < currentIndex || normalizedStatus === 'completed') {
                    item.classList.add('completed');
                    statusElement.textContent = 'âœ…';
                    statusElement.classList.remove('spinning');
                } else {
                    statusElement.textContent = 'â¸ï¸';
                    statusElement.classList.remove('spinning');
                }
            }
        });
    }
    
    /**
     * Update current message
     */
    updateMessage(message, requiresInput) {
        const messageContainer = this.container.querySelector('#current-message');
        const messageText = this.container.querySelector('#message-text');
        const messageIcon = messageContainer.querySelector('.message-icon');
        
        if (message) {
            messageText.textContent = message;
            messageIcon.textContent = requiresInput ? 'â“' : 'ğŸ’¬';
            messageContainer.classList.remove('hidden');
            
            if (requiresInput) {
                messageContainer.classList.add('requires-input');
            } else {
                messageContainer.classList.remove('requires-input');
            }
        } else {
            messageContainer.classList.add('hidden');
        }
    }
    
    /**
     * Update last updated timestamp
     */
    updateLastUpdated() {
        let timestampElement = this.container.querySelector('#last-updated');
        
        if (!timestampElement) {
            timestampElement = document.createElement('div');
            timestampElement.id = 'last-updated';
            timestampElement.className = 'last-updated';
            this.container.appendChild(timestampElement);
        }
        
        const now = new Date();
        const timeString = now.toLocaleTimeString('ko-KR');
        timestampElement.textContent = `ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${timeString}`;
    }
    
    /**
     * Request status update (for manual refresh)
     */
    requestStatusUpdate() {
        console.log('Manual status update requested');
        
        const refreshBtn = this.container.querySelector('#refresh-btn');
        refreshBtn.disabled = true;
        refreshBtn.textContent = 'ìƒˆë¡œê³ ì¹¨ ì¤‘...';
        
        setTimeout(() => {
            refreshBtn.disabled = false;
            refreshBtn.textContent = 'ìƒíƒœ ìƒˆë¡œê³ ì¹¨';
        }, 2000);
    }
    
    /**
     * Cancel workflow
     */
    cancelWorkflow() {
        if (confirm('ì •ë§ë¡œ ì‘ì—…ì„ ì·¨ì†Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
            console.log('Workflow cancellation requested');
        }
    }
    
    /**
     * Reset component
     */
    reset() {
        this.currentStatus = null;
        
        // Reset progress
        this.updateProgress(0);
        
        // Reset status
        this.updateStatusIndicator('started', '');
        
        // Reset steps
        const stepItems = this.container.querySelectorAll('.step-item');
        stepItems.forEach(item => {
            item.classList.remove('active', 'completed', 'error');
            const statusElement = item.querySelector('.step-status');
            statusElement.textContent = 'â¸ï¸';
        });
        
        // Hide message
        this.container.querySelector('#current-message').classList.add('hidden');
        
        // Hide thread info
        this.container.querySelector('#thread-info').classList.add('hidden');
        
        // Remove timestamp
        const timestampElement = this.container.querySelector('#last-updated');
        if (timestampElement) {
            timestampElement.remove();
        }
    }
    
    /**
     * Set thread ID for tracking
     */
    setThreadId(threadId) {
        this.threadId = threadId;

        // Update thread ID display
        const threadIdElement = this.container.querySelector('#thread-id');
        const threadInfoElement = this.container.querySelector('#thread-info');
        if (threadId) {
            threadIdElement.textContent = threadId;
            threadInfoElement.classList.remove('hidden');
        }

        // Initialize with processing state
        this.updateProgress(5);  // Start at 5% to show initial activity
        this.updateStatusIndicator('STARTING', 'analyze_problem');
        this.updateMessage('ë¶„ì„ ì‹œì‘ ì¤‘...', false);
    }
    
    /**
     * Get current status
     */
    getCurrentStatus() {
        return this.currentStatus;
    }
}

// Export for global use
window.ProgressTrackerComponent = ProgressTrackerComponent;

